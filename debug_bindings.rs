/* automatically generated by rust-bindgen 0.71.1 */

pub type in_buf32 = *const u8;
pub type out_str_buf = *mut *mut u8;
pub type in_ptr = *const *mut ::std::os::raw::c_void;
unsafe extern "C" {
    pub fn pedersen_commit(inputs_buffer: vec_in_buf, ctx_index: *const u32, output: out_buf);
}
unsafe extern "C" {
    pub fn pedersen_hash(inputs_buffer: vec_in_buf, hash_index: *const u32, output: out_buf);
}
unsafe extern "C" {
    pub fn pedersen_hashes(inputs_buffer: vec_in_buf, hash_index: *const u32, output: out_buf);
}
unsafe extern "C" {
    pub fn pedersen_hash_buffer(input_buffer: *const u8, hash_index: *const u32, output: out_buf);
}
unsafe extern "C" {
    pub fn blake2s(data: *const u8, r: out_buf32);
}
unsafe extern "C" {
    pub fn blake2s_to_field_(data: *const u8, r: out_buf);
}
unsafe extern "C" {
    pub fn schnorr_construct_signature(
        message: *const u8,
        private_key: in_buf,
        s: out_buf32,
        e: out_buf32,
    );
}
unsafe extern "C" {
    pub fn schnorr_verify_signature(
        message: *const u8,
        pub_key: in_buf,
        sig_s: in_buf32,
        sig_e: in_buf32,
        result: *mut bool,
    );
}
unsafe extern "C" {
    pub fn schnorr_multisig_create_multisig_public_key(
        private_key: in_buf,
        multisig_pubkey_buf: out_buf,
    );
}
unsafe extern "C" {
    pub fn schnorr_multisig_validate_and_combine_signer_pubkeys(
        signer_pubkey_buf: vec_in_buf,
        combined_key_buf: out_buf,
        success: *mut bool,
    );
}
unsafe extern "C" {
    pub fn schnorr_multisig_construct_signature_round_1(
        round_one_public_output_buf: out_buf,
        round_one_private_output_buf: out_buf,
    );
}
unsafe extern "C" {
    pub fn schnorr_multisig_construct_signature_round_2(
        message: *const u8,
        private_key: in_buf,
        signer_round_one_private_buf: in_buf,
        signer_pubkeys_buf: vec_in_buf,
        round_one_public_buf: vec_in_buf,
        round_two_buf: out_buf,
        success: *mut bool,
    );
}
unsafe extern "C" {
    pub fn schnorr_multisig_combine_signatures(
        message: *const u8,
        signer_pubkeys_buf: vec_in_buf,
        round_one_buf: vec_in_buf,
        round_two_buf: vec_in_buf,
        s: out_buf32,
        e: out_buf32,
        success: *mut bool,
    );
}
unsafe extern "C" {
    pub fn srs_init_srs(points_buf: *const u8, num_points: *const u32, g2_point_buf: *const u8);
}
unsafe extern "C" {
    pub fn srs_init_grumpkin_srs(points_buf: *const u8, num_points: *const u32);
}
unsafe extern "C" {
    pub fn test_threads(threads: *const u32, iterations: *const u32, out: *mut u32);
}
unsafe extern "C" {
    pub fn common_init_slab_allocator(circuit_size: *const u32);
}
unsafe extern "C" {
    pub fn acir_get_circuit_sizes(
        constraint_system_buf: *const u8,
        recursive: *const bool,
        honk_recursion: *const bool,
        total: *mut u32,
        subgroup: *mut u32,
    );
}
unsafe extern "C" {
    #[doc = " @brief Construct and verify an UltraHonk proof\n"]
    pub fn acir_prove_and_verify_ultra_honk(
        constraint_system_buf: *const u8,
        witness_buf: *const u8,
        result: *mut bool,
    );
}
unsafe extern "C" {
    pub fn acir_load_verification_key(acir_composer_ptr: in_ptr, vk_buf: *const u8);
}
unsafe extern "C" {
    pub fn acir_init_verification_key(acir_composer_ptr: in_ptr);
}
unsafe extern "C" {
    pub fn acir_get_verification_key(acir_composer_ptr: in_ptr, out: *mut *mut u8);
}
unsafe extern "C" {
    pub fn acir_get_proving_key(
        acir_composer_ptr: in_ptr,
        acir_vec: *const u8,
        recursive: *const bool,
        out: *mut *mut u8,
    );
}
unsafe extern "C" {
    pub fn acir_verify_proof(acir_composer_ptr: in_ptr, proof_buf: *const u8, result: *mut bool);
}
unsafe extern "C" {
    pub fn acir_get_solidity_verifier(acir_composer_ptr: in_ptr, out: out_str_buf);
}
unsafe extern "C" {
    pub fn acir_serialize_proof_into_fields(
        acir_composer_ptr: in_ptr,
        proof_buf: *const u8,
        num_inner_public_inputs: *const u32,
        out: vec_out_buf,
    );
}
unsafe extern "C" {
    pub fn acir_serialize_verification_key_into_fields(
        acir_composer_ptr: in_ptr,
        out_vkey: vec_out_buf,
        out_key_hash: out_buf,
    );
}
unsafe extern "C" {
    pub fn acir_prove_ultra_honk(acir_vec: *const u8, witness_vec: *const u8, out: *mut *mut u8);
}
unsafe extern "C" {
    pub fn acir_verify_ultra_honk(proof_buf: *const u8, vk_buf: *const u8, result: *mut bool);
}
unsafe extern "C" {
    pub fn acir_write_vk_ultra_honk(acir_vec: *const u8, out: *mut *mut u8);
}
unsafe extern "C" {
    pub fn acir_proof_as_fields_ultra_honk(proof_buf: *const u8, out: vec_out_buf);
}
pub type vec_out_buf = *mut *mut u8;
